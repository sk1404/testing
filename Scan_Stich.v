
// Generated by Cadence Genus(TM) Synthesis Solution 20.10-p001_1
// Generated on: Jul 12 2025 14:28:48 IST (Jul 12 2025 08:58:48 UTC)

// Verification Directory fv/counter_4bit 

`timescale 1ns/1ps

module scan_dff_mux (
    input  wire D,     // Normal data input
    input  wire SD,    // Scan data input
    input  wire SE,    // Scan enable (mux select)
    input  wire CLK,   // Clock
    input  wire RST,   // Asynchronous active-high reset
    output reg  Q      // Output
);

    wire mux_out;

    // 2:1 MUX: If SE == 1, select SD; else select D
    assign mux_out = SE ? SD : D;

    // Positive-edge triggered DFF with async reset
    always @(posedge CLK or posedge RST) begin
        if (RST)
            Q <= 1'b0;
        else
            Q <= mux_out;
    end

endmodule

module counter_4bit(clk, reset,SE,SD,count);
  input clk, reset,SE,SD;
  output [3:0] count;
  wire clk, reset,SE,SD;
  wire [3:0] count;
  wire n_0, n_1, n_2, n_3, n_4, n_5, n_6, n_7;
  wire n_8;
  //DFFHQX1 \count_reg[3] (.CK (clk), .D (n_8), .Q (count[3]));
  scan_dff_mux s4(.D(n_8),.SD(count[2]),.SE(SE),.CLK(clk),.RST(reset),.Q(count[3]));
  NOR2XL g60(.A (reset), .B (n_7), .Y (n_8));
 // DFFHQX1 \count_reg[2] (.CK (clk), .D (n_6), .Q (count[2]));

 scan_dff_mux s3(.D(n_6),.SD(count[1]),.SE(SE),.CLK(clk),.RST(reset),.Q(count[2]));
  //DFFHQX1 \count_reg[1] (.CK (clk), .D (n_4), .Q (count[1]));

 scan_dff_mux s2(.D(n_4),.SD(count[0]),.SE(SE),.CLK(clk),.RST(reset),.Q(count[1]));
  XNOR2X1 g62(.A (n_5), .B (count[3]), .Y (n_7));
  AOI211XL g63(.A0 (n_1), .A1 (n_2), .B0 (reset), .C0 (n_5), .Y (n_6));
  NOR2XL g66(.A (reset), .B (n_3), .Y (n_4));
  OAI21XL g68(.A0 (count[0]), .A1 (count[1]), .B0 (n_2), .Y (n_3));
  NOR2XL g65(.A (n_1), .B (n_2), .Y (n_5));

 // DFFHQX1 \count_reg[0] (.CK (clk), .D (n_0), .Q (count[0]));
 scan_dff_mux s1(.D(n_0),.SD(SD),.SE(SE),.CLK(clk),.RST(reset),.Q(count[0]));
  NOR2XL g69(.A (reset), .B (count[0]), .Y (n_0));
  NAND2XL g70(.A (count[1]), .B (count[0]), .Y (n_2));
  INVXL g71(.A (count[2]), .Y (n_1));
endmodule


module counter_4bit_tb;

    // Testbench signals
    reg clk;
    reg reset;
    reg SE;
    reg SD;
    wire [3:0] count;

    // Instantiate the DUT (Device Under Test)
    counter_4bit dut (
        .clk(clk),
        .reset(reset),
        .SE(SE),
        .SD(SD),
        .count(count)
    );

    // Clock generator: 10ns period
    always #5 clk = ~clk;

    initial begin
        $display("Starting testbench...");
        $monitor("Time=%0t | rst=%b SE=%b SD=%b count=%b", $time, reset, SE, SD, count);

        // Initialize signals
        clk = 0;
        reset = 1;
        SE = 0;
        SD = 0;

        // Reset pulse
        #10 reset = 0;

        // Let counter run
        #100;

        // Test scan-enable feature
        SE = 1;
        SD = 1;

        #20 SE = 0;

        // More simulation time
        #100;

        $finish;
    end
endmodule

